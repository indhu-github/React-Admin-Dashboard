{"ast":null,"code":"import { createSelector } from '../../../utils/createSelector';\nimport { gridVisibleSortedRowEntriesSelector, gridVisibleSortedRowIdsSelector, gridVisibleSortedTopLevelRowEntriesSelector } from '../filter/gridFilterSelector';\nimport { gridRowTreeDepthSelector, gridRowTreeSelector } from '../rows/gridRowsSelector';\n/**\n * @category Pagination\n * @ignore - do not document.\n */\n\nexport const gridPaginationSelector = state => state.pagination;\n/**\n * Get the index of the page to render if the pagination is enabled\n * @category Pagination\n */\n\nexport const gridPageSelector = createSelector(gridPaginationSelector, pagination => pagination.page);\n/**\n * Get the maximum amount of rows to display on a single page if the pagination is enabled\n * @category Pagination\n */\n\nexport const gridPageSizeSelector = createSelector(gridPaginationSelector, pagination => pagination.pageSize);\n/**\n * Get the amount of pages needed to display all the rows if the pagination is enabled\n * @category Pagination\n */\n\nexport const gridPageCountSelector = createSelector(gridPaginationSelector, pagination => pagination.pageCount);\n/**\n * Get the index of the first and the last row to include in the current page if the pagination is enabled.\n * @category Pagination\n */\n\nexport const gridPaginationRowRangeSelector = createSelector(gridPaginationSelector, gridRowTreeSelector, gridRowTreeDepthSelector, gridVisibleSortedRowEntriesSelector, gridVisibleSortedTopLevelRowEntriesSelector, (pagination, rowTree, rowTreeDepth, visibleSortedRowEntries, visibleSortedTopLevelRowEntries) => {\n  const visibleTopLevelRowCount = visibleSortedTopLevelRowEntries.length;\n  const topLevelFirstRowIndex = Math.min(pagination.pageSize * pagination.page, visibleTopLevelRowCount - 1);\n  const topLevelLastRowIndex = Math.min(topLevelFirstRowIndex + pagination.pageSize - 1, visibleTopLevelRowCount - 1); // The range contains no element\n\n  if (topLevelFirstRowIndex === -1 || topLevelLastRowIndex === -1) {\n    return null;\n  } // The tree is flat, there is no need to look for children\n\n  if (rowTreeDepth < 2) {\n    return {\n      firstRowIndex: topLevelFirstRowIndex,\n      lastRowIndex: topLevelLastRowIndex\n    };\n  }\n  const topLevelFirstRow = visibleSortedTopLevelRowEntries[topLevelFirstRowIndex];\n  const topLevelRowsInCurrentPageCount = topLevelLastRowIndex - topLevelFirstRowIndex + 1;\n  const firstRowIndex = visibleSortedRowEntries.findIndex(row => row.id === topLevelFirstRow.id);\n  let lastRowIndex = firstRowIndex;\n  let topLevelRowAdded = 0;\n  while (lastRowIndex < visibleSortedRowEntries.length && topLevelRowAdded <= topLevelRowsInCurrentPageCount) {\n    const row = visibleSortedRowEntries[lastRowIndex];\n    const depth = rowTree[row.id].depth;\n    if (topLevelRowAdded < topLevelRowsInCurrentPageCount || depth > 0) {\n      lastRowIndex += 1;\n    }\n    if (depth === 0) {\n      topLevelRowAdded += 1;\n    }\n  }\n  return {\n    firstRowIndex,\n    lastRowIndex: lastRowIndex - 1\n  };\n});\n/**\n * Get the id and the model of each row to include in the current page if the pagination is enabled.\n * @category Pagination\n */\n\nexport const gridPaginatedVisibleSortedGridRowEntriesSelector = createSelector(gridVisibleSortedRowEntriesSelector, gridPaginationRowRangeSelector, (visibleSortedRowEntries, paginationRange) => {\n  if (!paginationRange) {\n    return [];\n  }\n  return visibleSortedRowEntries.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);\n});\n/**\n * Get the id of each row to include in the current page if the pagination is enabled.\n * @category Pagination\n */\n\nexport const gridPaginatedVisibleSortedGridRowIdsSelector = createSelector(gridVisibleSortedRowIdsSelector, gridPaginationRowRangeSelector, (visibleSortedRowIds, paginationRange) => {\n  if (!paginationRange) {\n    return [];\n  }\n  return visibleSortedRowIds.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);\n});","map":{"version":3,"names":["createSelector","gridVisibleSortedRowEntriesSelector","gridVisibleSortedRowIdsSelector","gridVisibleSortedTopLevelRowEntriesSelector","gridRowTreeDepthSelector","gridRowTreeSelector","gridPaginationSelector","state","pagination","gridPageSelector","page","gridPageSizeSelector","pageSize","gridPageCountSelector","pageCount","gridPaginationRowRangeSelector","rowTree","rowTreeDepth","visibleSortedRowEntries","visibleSortedTopLevelRowEntries","visibleTopLevelRowCount","length","topLevelFirstRowIndex","Math","min","topLevelLastRowIndex","firstRowIndex","lastRowIndex","topLevelFirstRow","topLevelRowsInCurrentPageCount","findIndex","row","id","topLevelRowAdded","depth","gridPaginatedVisibleSortedGridRowEntriesSelector","paginationRange","slice","gridPaginatedVisibleSortedGridRowIdsSelector","visibleSortedRowIds"],"sources":["/Users/indhuyelineni/Desktop/Projects/React-Dashboard/node_modules/@mui/x-data-grid/hooks/features/pagination/gridPaginationSelector.js"],"sourcesContent":["import { createSelector } from '../../../utils/createSelector';\nimport { gridVisibleSortedRowEntriesSelector, gridVisibleSortedRowIdsSelector, gridVisibleSortedTopLevelRowEntriesSelector } from '../filter/gridFilterSelector';\nimport { gridRowTreeDepthSelector, gridRowTreeSelector } from '../rows/gridRowsSelector';\n/**\n * @category Pagination\n * @ignore - do not document.\n */\n\nexport const gridPaginationSelector = state => state.pagination;\n/**\n * Get the index of the page to render if the pagination is enabled\n * @category Pagination\n */\n\nexport const gridPageSelector = createSelector(gridPaginationSelector, pagination => pagination.page);\n/**\n * Get the maximum amount of rows to display on a single page if the pagination is enabled\n * @category Pagination\n */\n\nexport const gridPageSizeSelector = createSelector(gridPaginationSelector, pagination => pagination.pageSize);\n/**\n * Get the amount of pages needed to display all the rows if the pagination is enabled\n * @category Pagination\n */\n\nexport const gridPageCountSelector = createSelector(gridPaginationSelector, pagination => pagination.pageCount);\n/**\n * Get the index of the first and the last row to include in the current page if the pagination is enabled.\n * @category Pagination\n */\n\nexport const gridPaginationRowRangeSelector = createSelector(gridPaginationSelector, gridRowTreeSelector, gridRowTreeDepthSelector, gridVisibleSortedRowEntriesSelector, gridVisibleSortedTopLevelRowEntriesSelector, (pagination, rowTree, rowTreeDepth, visibleSortedRowEntries, visibleSortedTopLevelRowEntries) => {\n  const visibleTopLevelRowCount = visibleSortedTopLevelRowEntries.length;\n  const topLevelFirstRowIndex = Math.min(pagination.pageSize * pagination.page, visibleTopLevelRowCount - 1);\n  const topLevelLastRowIndex = Math.min(topLevelFirstRowIndex + pagination.pageSize - 1, visibleTopLevelRowCount - 1); // The range contains no element\n\n  if (topLevelFirstRowIndex === -1 || topLevelLastRowIndex === -1) {\n    return null;\n  } // The tree is flat, there is no need to look for children\n\n\n  if (rowTreeDepth < 2) {\n    return {\n      firstRowIndex: topLevelFirstRowIndex,\n      lastRowIndex: topLevelLastRowIndex\n    };\n  }\n\n  const topLevelFirstRow = visibleSortedTopLevelRowEntries[topLevelFirstRowIndex];\n  const topLevelRowsInCurrentPageCount = topLevelLastRowIndex - topLevelFirstRowIndex + 1;\n  const firstRowIndex = visibleSortedRowEntries.findIndex(row => row.id === topLevelFirstRow.id);\n  let lastRowIndex = firstRowIndex;\n  let topLevelRowAdded = 0;\n\n  while (lastRowIndex < visibleSortedRowEntries.length && topLevelRowAdded <= topLevelRowsInCurrentPageCount) {\n    const row = visibleSortedRowEntries[lastRowIndex];\n    const depth = rowTree[row.id].depth;\n\n    if (topLevelRowAdded < topLevelRowsInCurrentPageCount || depth > 0) {\n      lastRowIndex += 1;\n    }\n\n    if (depth === 0) {\n      topLevelRowAdded += 1;\n    }\n  }\n\n  return {\n    firstRowIndex,\n    lastRowIndex: lastRowIndex - 1\n  };\n});\n/**\n * Get the id and the model of each row to include in the current page if the pagination is enabled.\n * @category Pagination\n */\n\nexport const gridPaginatedVisibleSortedGridRowEntriesSelector = createSelector(gridVisibleSortedRowEntriesSelector, gridPaginationRowRangeSelector, (visibleSortedRowEntries, paginationRange) => {\n  if (!paginationRange) {\n    return [];\n  }\n\n  return visibleSortedRowEntries.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);\n});\n/**\n * Get the id of each row to include in the current page if the pagination is enabled.\n * @category Pagination\n */\n\nexport const gridPaginatedVisibleSortedGridRowIdsSelector = createSelector(gridVisibleSortedRowIdsSelector, gridPaginationRowRangeSelector, (visibleSortedRowIds, paginationRange) => {\n  if (!paginationRange) {\n    return [];\n  }\n\n  return visibleSortedRowIds.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}