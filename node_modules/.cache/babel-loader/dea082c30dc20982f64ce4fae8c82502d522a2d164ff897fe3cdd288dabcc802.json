{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowsLookupSelector } from '../rows/gridRowsSelector';\nimport { gridSelectionStateSelector, selectedGridRowsSelector, selectedIdsLookupSelector } from './gridSelectionSelector';\nimport { gridPaginatedVisibleSortedGridRowIdsSelector } from '../pagination';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridVisibleSortedRowIdsSelector } from '../filter/gridFilterSelector';\nimport { GRID_CHECKBOX_SELECTION_COL_DEF, GRID_ACTIONS_COLUMN_TYPE } from '../../../colDef';\nimport { GridCellModes } from '../../../models/gridEditRowModel';\nimport { isKeyboardEvent, isNavigationKey } from '../../../utils/keyboardUtils';\nimport { getVisibleRows, useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from '../../../constants/gridDetailPanelToggleField';\nconst getSelectionModelPropValue = (selectionModelProp, prevSelectionModel) => {\n  if (selectionModelProp == null) {\n    return selectionModelProp;\n  }\n  if (Array.isArray(selectionModelProp)) {\n    return selectionModelProp;\n  }\n  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {\n    return prevSelectionModel;\n  }\n  return [selectionModelProp];\n};\nexport const selectionStateInitializer = (state, props) => {\n  var _getSelectionModelPro;\n  return _extends({}, state, {\n    selection: (_getSelectionModelPro = getSelectionModelPropValue(props.selectionModel)) != null ? _getSelectionModelPro : []\n  });\n};\n/**\n * @requires useGridRows (state, method) - can be after\n * @requires useGridParamsApi (method) - can be after\n * @requires useGridFocus (state) - can be after\n * @requires useGridKeyboardNavigation (`cellKeyDown` event must first be consumed by it)\n */\n\nexport const useGridSelection = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridSelection');\n  const propSelectionModel = React.useMemo(() => {\n    return getSelectionModelPropValue(props.selectionModel, gridSelectionStateSelector(apiRef.current.state));\n  }, [apiRef, props.selectionModel]);\n  const lastRowToggled = React.useRef(null);\n  apiRef.current.unstable_registerControlState({\n    stateId: 'selection',\n    propModel: propSelectionModel,\n    propOnChange: props.onSelectionModelChange,\n    stateSelector: gridSelectionStateSelector,\n    changeEvent: 'selectionChange'\n  });\n  const {\n    checkboxSelection,\n    disableMultipleSelection,\n    disableSelectionOnClick,\n    pagination,\n    paginationMode,\n    isRowSelectable: propIsRowSelectable\n  } = props;\n  const canHaveMultipleSelection = !disableMultipleSelection || checkboxSelection;\n  const visibleRows = useGridVisibleRows(apiRef, props);\n  const expandMouseRowRangeSelection = React.useCallback(id => {\n    var _lastRowToggled$curre;\n    let endId = id;\n    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;\n    const isSelected = apiRef.current.isRowSelected(id);\n    if (isSelected) {\n      const visibleRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n      const startIndex = visibleRowIds.findIndex(rowId => rowId === startId);\n      const endIndex = visibleRowIds.findIndex(rowId => rowId === endId);\n      if (startIndex === endIndex) {\n        return;\n      }\n      if (startIndex > endIndex) {\n        endId = visibleRowIds[endIndex + 1];\n      } else {\n        endId = visibleRowIds[endIndex - 1];\n      }\n    }\n    lastRowToggled.current = id;\n    apiRef.current.selectRowRange({\n      startId,\n      endId\n    }, !isSelected);\n  }, [apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setSelectionModel = React.useCallback(model => {\n    const currentModel = gridSelectionStateSelector(apiRef.current.state);\n    if (currentModel !== model) {\n      logger.debug(`Setting selection model`);\n      apiRef.current.setState(state => _extends({}, state, {\n        selection: model\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, logger]);\n  const isRowSelected = React.useCallback(id => gridSelectionStateSelector(apiRef.current.state).includes(id), [apiRef]);\n  const isRowSelectable = React.useCallback(id => {\n    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id))) {\n      return false;\n    }\n    const rowNode = apiRef.current.getRowNode(id);\n    if ((rowNode == null ? void 0 : rowNode.position) === 'footer' || rowNode != null && rowNode.isPinned) {\n      return false;\n    }\n    return true;\n  }, [apiRef, propIsRowSelectable]);\n  const getSelectedRows = React.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);\n  const selectRow = React.useCallback(function (id) {\n    let isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!apiRef.current.isRowSelectable(id)) {\n      return;\n    }\n    lastRowToggled.current = id;\n    if (resetSelection) {\n      logger.debug(`Setting selection for row ${id}`);\n      apiRef.current.setSelectionModel(isSelected ? [id] : []);\n    } else {\n      logger.debug(`Toggling selection for row ${id}`);\n      const selection = gridSelectionStateSelector(apiRef.current.state);\n      const newSelection = selection.filter(el => el !== id);\n      if (isSelected) {\n        newSelection.push(id);\n      }\n      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n      if (isSelectionValid) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRows = React.useCallback(function (ids) {\n    let isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let resetSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    logger.debug(`Setting selection for several rows`);\n    const selectableIds = ids.filter(id => apiRef.current.isRowSelectable(id));\n    let newSelection;\n    if (resetSelection) {\n      newSelection = isSelected ? selectableIds : [];\n    } else {\n      // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n      const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n      selectableIds.forEach(id => {\n        if (isSelected) {\n          selectionLookup[id] = id;\n        } else {\n          delete selectionLookup[id];\n        }\n      });\n      newSelection = Object.values(selectionLookup);\n    }\n    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n    if (isSelectionValid) {\n      apiRef.current.setSelectionModel(newSelection);\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRowRange = React.useCallback(function (_ref) {\n    let {\n      startId,\n      endId\n    } = _ref;\n    let isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let resetSelection = arguments.length > 2 ? arguments[2] : undefined;\n    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {\n      return;\n    }\n    logger.debug(`Expanding selection from row ${startId} to row ${endId}`); // Using rows from all pages allow to select a range across several pages\n\n    const allPagesRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n    const startIndex = allPagesRowIds.indexOf(startId);\n    const endIndex = allPagesRowIds.indexOf(endId);\n    const [start, end] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];\n    const rowsBetweenStartAndEnd = allPagesRowIds.slice(start, end + 1);\n    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);\n  }, [apiRef, logger]);\n  const selectionApi = {\n    selectRow,\n    selectRows,\n    selectRowRange,\n    setSelectionModel,\n    getSelectedRows,\n    isRowSelected,\n    isRowSelectable\n  };\n  useGridApiMethod(apiRef, selectionApi, 'GridSelectionApi');\n  /**\n   * EVENTS\n   */\n\n  const removeOutdatedSelection = React.useCallback(() => {\n    if (props.keepNonExistentRowsSelected) {\n      return;\n    }\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n    const rowsLookup = gridRowsLookupSelector(apiRef); // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n\n    const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n    let hasChanged = false;\n    currentSelection.forEach(id => {\n      if (!rowsLookup[id]) {\n        delete selectionLookup[id];\n        hasChanged = true;\n      }\n    });\n    if (hasChanged) {\n      apiRef.current.setSelectionModel(Object.values(selectionLookup));\n    }\n  }, [apiRef, props.keepNonExistentRowsSelected]);\n  const handleSingleRowSelection = React.useCallback((id, event) => {\n    const hasCtrlKey = event.metaKey || event.ctrlKey; // multiple selection is only allowed if:\n    // - it is a checkboxSelection\n    // - it is a keyboard selection\n    // - Ctrl is pressed\n\n    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);\n    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;\n    const isSelected = apiRef.current.isRowSelected(id);\n    if (resetSelection) {\n      apiRef.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);\n    } else {\n      apiRef.current.selectRow(id, !isSelected, false);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);\n  const handleCellClick = React.useCallback((params, event) => {\n    if (disableSelectionOnClick) {\n      return;\n    }\n    if (params.field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {\n      // click on checkbox should not trigger row selection\n      return;\n    }\n    if (params.field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {\n      // click to open the detail panel should not select the row\n      return;\n    }\n    if (params.field) {\n      const column = apiRef.current.getColumn(params.field);\n      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {\n        return;\n      }\n    }\n    if (params.rowNode.isPinned) {\n      return;\n    }\n    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      handleSingleRowSelection(params.id, event);\n    }\n  }, [disableSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);\n  const preventSelectionOnShift = React.useCallback((params, event) => {\n    if (canHaveMultipleSelection && event.shiftKey) {\n      var _window$getSelection;\n      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();\n    }\n  }, [canHaveMultipleSelection]);\n  const handleRowSelectionCheckboxChange = React.useCallback((params, event) => {\n    if (event.nativeEvent.shiftKey) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      apiRef.current.selectRow(params.id, params.value);\n    }\n  }, [apiRef, expandMouseRowRangeSelection]);\n  const handleHeaderSelectionCheckboxChange = React.useCallback(params => {\n    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;\n    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridVisibleSortedRowIdsSelector(apiRef);\n    apiRef.current.selectRows(rowsToBeSelected, params.value);\n  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);\n  const handleCellKeyDown = React.useCallback((params, event) => {\n    // Get the most recent cell mode because it may have been changed by another listener\n    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {\n      return;\n    } // Ignore portal\n    // Do not apply shortcuts if the focus is not on the cell root component\n\n    if (!event.currentTarget.contains(event.target)) {\n      return;\n    }\n    if (isNavigationKey(event.key) && event.shiftKey) {\n      // The cell that has focus after the keyboard navigation\n      const focusCell = gridFocusCellSelector(apiRef);\n      if (focusCell && focusCell.id !== params.id) {\n        event.preventDefault();\n        const isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);\n        if (!canHaveMultipleSelection) {\n          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);\n          return;\n        }\n        const newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);\n        const previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);\n        let start;\n        let end;\n        if (newRowIndex > previousRowIndex) {\n          if (isNextRowSelected) {\n            // We are navigating to the bottom of the page and adding selected rows\n            start = previousRowIndex;\n            end = newRowIndex - 1;\n          } else {\n            // We are navigating to the bottom of the page and removing selected rows\n            start = previousRowIndex;\n            end = newRowIndex;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isNextRowSelected) {\n            // We are navigating to the top of the page and removing selected rows\n            start = newRowIndex + 1;\n            end = previousRowIndex;\n          } else {\n            // We are navigating to the top of the page and adding selected rows\n            start = newRowIndex;\n            end = previousRowIndex;\n          }\n        }\n        const rowsBetweenStartAndEnd = visibleRows.rows.slice(start, end + 1).map(row => row.id);\n        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);\n        return;\n      }\n    }\n    if (event.key === ' ' && event.shiftKey) {\n      event.preventDefault();\n      handleSingleRowSelection(params.id, event);\n      return;\n    }\n    if (event.key.toLowerCase() === 'a' && (event.ctrlKey || event.metaKey)) {\n      event.preventDefault();\n      selectRows(apiRef.current.getAllRowIds(), true);\n    }\n  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', removeOutdatedSelection);\n  useGridApiEventHandler(apiRef, 'cellClick', handleCellClick);\n  useGridApiEventHandler(apiRef, 'rowSelectionCheckboxChange', handleRowSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'headerSelectionCheckboxChange', handleHeaderSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'cellMouseDown', preventSelectionOnShift);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handleCellKeyDown);\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    if (propSelectionModel !== undefined) {\n      apiRef.current.setSelectionModel(propSelectionModel);\n    }\n  }, [apiRef, propSelectionModel]);\n  const isStateControlled = propSelectionModel != null;\n  React.useEffect(() => {\n    if (isStateControlled) {\n      return;\n    } // props.isRowSelectable changed\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n    if (isRowSelectable) {\n      const newSelection = currentSelection.filter(id => isRowSelectable(id));\n      if (newSelection.length < currentSelection.length) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, isRowSelectable, isStateControlled]);\n  React.useEffect(() => {\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n    if (!canHaveMultipleSelection && currentSelection.length > 1) {\n      const {\n        rows: currentPageRows\n      } = getVisibleRows(apiRef, {\n        pagination,\n        paginationMode\n      });\n      const currentPageRowsLookup = currentPageRows.reduce((acc, _ref2) => {\n        let {\n          id\n        } = _ref2;\n        acc[id] = true;\n        return acc;\n      }, {});\n      const firstSelectableRow = currentSelection.find(id => {\n        let isSelectable = true;\n        if (isRowSelectable) {\n          isSelectable = isRowSelectable(id);\n        }\n        return isSelectable && currentPageRowsLookup[id]; // Check if the row is in the current page\n      });\n\n      apiRef.current.setSelectionModel(firstSelectableRow !== undefined ? [firstSelectableRow] : []);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleSelection, isRowSelectable, pagination, paginationMode]);\n};","map":{"version":3,"names":["_extends","React","useGridApiEventHandler","useGridApiMethod","useGridLogger","gridRowsLookupSelector","gridSelectionStateSelector","selectedGridRowsSelector","selectedIdsLookupSelector","gridPaginatedVisibleSortedGridRowIdsSelector","gridFocusCellSelector","gridVisibleSortedRowIdsSelector","GRID_CHECKBOX_SELECTION_COL_DEF","GRID_ACTIONS_COLUMN_TYPE","GridCellModes","isKeyboardEvent","isNavigationKey","getVisibleRows","useGridVisibleRows","GRID_DETAIL_PANEL_TOGGLE_FIELD","getSelectionModelPropValue","selectionModelProp","prevSelectionModel","Array","isArray","selectionStateInitializer","state","props","_getSelectionModelPro","selection","selectionModel","useGridSelection","apiRef","logger","propSelectionModel","useMemo","current","lastRowToggled","useRef","unstable_registerControlState","stateId","propModel","propOnChange","onSelectionModelChange","stateSelector","changeEvent","checkboxSelection","disableMultipleSelection","disableSelectionOnClick","pagination","paginationMode","isRowSelectable","propIsRowSelectable","canHaveMultipleSelection","visibleRows","expandMouseRowRangeSelection","useCallback","id","_lastRowToggled$curre","endId","startId","isSelected","isRowSelected","visibleRowIds","startIndex","findIndex","rowId","endIndex","selectRowRange","setSelectionModel","model","currentModel","debug","setState","forceUpdate","includes","getRowParams","rowNode","getRowNode","position","isPinned","getSelectedRows","selectRow","resetSelection","newSelection","filter","el","push","isSelectionValid","length","selectRows","ids","selectableIds","selectionLookup","forEach","Object","values","getRow","allPagesRowIds","indexOf","start","end","rowsBetweenStartAndEnd","slice","selectionApi","removeOutdatedSelection","keepNonExistentRowsSelected","currentSelection","rowsLookup","hasChanged","handleSingleRowSelection","event","hasCtrlKey","metaKey","ctrlKey","isMultipleSelectionDisabled","handleCellClick","params","field","column","getColumn","type","shiftKey","preventSelectionOnShift","_window$getSelection","window","getSelection","removeAllRanges","handleRowSelectionCheckboxChange","nativeEvent","value","handleHeaderSelectionCheckboxChange","shouldLimitSelectionToCurrentPage","checkboxSelectionVisibleOnly","rowsToBeSelected","handleCellKeyDown","getCellMode","Edit","currentTarget","contains","target","key","focusCell","preventDefault","isNextRowSelected","newRowIndex","getRowIndexRelativeToVisibleRows","previousRowIndex","rows","map","row","toLowerCase","getAllRowIds","useEffect","undefined","isStateControlled","currentPageRows","currentPageRowsLookup","reduce","acc","firstSelectableRow","find","isSelectable"],"sources":["/Users/indhuyelineni/Desktop/Projects/React-Dashboard/node_modules/@mui/x-data-grid/hooks/features/selection/useGridSelection.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowsLookupSelector } from '../rows/gridRowsSelector';\nimport { gridSelectionStateSelector, selectedGridRowsSelector, selectedIdsLookupSelector } from './gridSelectionSelector';\nimport { gridPaginatedVisibleSortedGridRowIdsSelector } from '../pagination';\nimport { gridFocusCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridVisibleSortedRowIdsSelector } from '../filter/gridFilterSelector';\nimport { GRID_CHECKBOX_SELECTION_COL_DEF, GRID_ACTIONS_COLUMN_TYPE } from '../../../colDef';\nimport { GridCellModes } from '../../../models/gridEditRowModel';\nimport { isKeyboardEvent, isNavigationKey } from '../../../utils/keyboardUtils';\nimport { getVisibleRows, useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from '../../../constants/gridDetailPanelToggleField';\n\nconst getSelectionModelPropValue = (selectionModelProp, prevSelectionModel) => {\n  if (selectionModelProp == null) {\n    return selectionModelProp;\n  }\n\n  if (Array.isArray(selectionModelProp)) {\n    return selectionModelProp;\n  }\n\n  if (prevSelectionModel && prevSelectionModel[0] === selectionModelProp) {\n    return prevSelectionModel;\n  }\n\n  return [selectionModelProp];\n};\n\nexport const selectionStateInitializer = (state, props) => {\n  var _getSelectionModelPro;\n\n  return _extends({}, state, {\n    selection: (_getSelectionModelPro = getSelectionModelPropValue(props.selectionModel)) != null ? _getSelectionModelPro : []\n  });\n};\n/**\n * @requires useGridRows (state, method) - can be after\n * @requires useGridParamsApi (method) - can be after\n * @requires useGridFocus (state) - can be after\n * @requires useGridKeyboardNavigation (`cellKeyDown` event must first be consumed by it)\n */\n\nexport const useGridSelection = (apiRef, props) => {\n  const logger = useGridLogger(apiRef, 'useGridSelection');\n  const propSelectionModel = React.useMemo(() => {\n    return getSelectionModelPropValue(props.selectionModel, gridSelectionStateSelector(apiRef.current.state));\n  }, [apiRef, props.selectionModel]);\n  const lastRowToggled = React.useRef(null);\n  apiRef.current.unstable_registerControlState({\n    stateId: 'selection',\n    propModel: propSelectionModel,\n    propOnChange: props.onSelectionModelChange,\n    stateSelector: gridSelectionStateSelector,\n    changeEvent: 'selectionChange'\n  });\n  const {\n    checkboxSelection,\n    disableMultipleSelection,\n    disableSelectionOnClick,\n    pagination,\n    paginationMode,\n    isRowSelectable: propIsRowSelectable\n  } = props;\n  const canHaveMultipleSelection = !disableMultipleSelection || checkboxSelection;\n  const visibleRows = useGridVisibleRows(apiRef, props);\n  const expandMouseRowRangeSelection = React.useCallback(id => {\n    var _lastRowToggled$curre;\n\n    let endId = id;\n    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id;\n    const isSelected = apiRef.current.isRowSelected(id);\n\n    if (isSelected) {\n      const visibleRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n      const startIndex = visibleRowIds.findIndex(rowId => rowId === startId);\n      const endIndex = visibleRowIds.findIndex(rowId => rowId === endId);\n\n      if (startIndex === endIndex) {\n        return;\n      }\n\n      if (startIndex > endIndex) {\n        endId = visibleRowIds[endIndex + 1];\n      } else {\n        endId = visibleRowIds[endIndex - 1];\n      }\n    }\n\n    lastRowToggled.current = id;\n    apiRef.current.selectRowRange({\n      startId,\n      endId\n    }, !isSelected);\n  }, [apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setSelectionModel = React.useCallback(model => {\n    const currentModel = gridSelectionStateSelector(apiRef.current.state);\n\n    if (currentModel !== model) {\n      logger.debug(`Setting selection model`);\n      apiRef.current.setState(state => _extends({}, state, {\n        selection: model\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, logger]);\n  const isRowSelected = React.useCallback(id => gridSelectionStateSelector(apiRef.current.state).includes(id), [apiRef]);\n  const isRowSelectable = React.useCallback(id => {\n    if (propIsRowSelectable && !propIsRowSelectable(apiRef.current.getRowParams(id))) {\n      return false;\n    }\n\n    const rowNode = apiRef.current.getRowNode(id);\n\n    if ((rowNode == null ? void 0 : rowNode.position) === 'footer' || rowNode != null && rowNode.isPinned) {\n      return false;\n    }\n\n    return true;\n  }, [apiRef, propIsRowSelectable]);\n  const getSelectedRows = React.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);\n  const selectRow = React.useCallback((id, isSelected = true, resetSelection = false) => {\n    if (!apiRef.current.isRowSelectable(id)) {\n      return;\n    }\n\n    lastRowToggled.current = id;\n\n    if (resetSelection) {\n      logger.debug(`Setting selection for row ${id}`);\n      apiRef.current.setSelectionModel(isSelected ? [id] : []);\n    } else {\n      logger.debug(`Toggling selection for row ${id}`);\n      const selection = gridSelectionStateSelector(apiRef.current.state);\n      const newSelection = selection.filter(el => el !== id);\n\n      if (isSelected) {\n        newSelection.push(id);\n      }\n\n      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n\n      if (isSelectionValid) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRows = React.useCallback((ids, isSelected = true, resetSelection = false) => {\n    logger.debug(`Setting selection for several rows`);\n    const selectableIds = ids.filter(id => apiRef.current.isRowSelectable(id));\n    let newSelection;\n\n    if (resetSelection) {\n      newSelection = isSelected ? selectableIds : [];\n    } else {\n      // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n      const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n\n      selectableIds.forEach(id => {\n        if (isSelected) {\n          selectionLookup[id] = id;\n        } else {\n          delete selectionLookup[id];\n        }\n      });\n      newSelection = Object.values(selectionLookup);\n    }\n\n    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;\n\n    if (isSelectionValid) {\n      apiRef.current.setSelectionModel(newSelection);\n    }\n  }, [apiRef, logger, canHaveMultipleSelection]);\n  const selectRowRange = React.useCallback(({\n    startId,\n    endId\n  }, isSelected = true, resetSelection) => {\n    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {\n      return;\n    }\n\n    logger.debug(`Expanding selection from row ${startId} to row ${endId}`); // Using rows from all pages allow to select a range across several pages\n\n    const allPagesRowIds = gridVisibleSortedRowIdsSelector(apiRef);\n    const startIndex = allPagesRowIds.indexOf(startId);\n    const endIndex = allPagesRowIds.indexOf(endId);\n    const [start, end] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];\n    const rowsBetweenStartAndEnd = allPagesRowIds.slice(start, end + 1);\n    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);\n  }, [apiRef, logger]);\n  const selectionApi = {\n    selectRow,\n    selectRows,\n    selectRowRange,\n    setSelectionModel,\n    getSelectedRows,\n    isRowSelected,\n    isRowSelectable\n  };\n  useGridApiMethod(apiRef, selectionApi, 'GridSelectionApi');\n  /**\n   * EVENTS\n   */\n\n  const removeOutdatedSelection = React.useCallback(() => {\n    if (props.keepNonExistentRowsSelected) {\n      return;\n    }\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n    const rowsLookup = gridRowsLookupSelector(apiRef); // We clone the existing object to avoid mutating the same object returned by the selector to others part of the project\n\n    const selectionLookup = _extends({}, selectedIdsLookupSelector(apiRef));\n\n    let hasChanged = false;\n    currentSelection.forEach(id => {\n      if (!rowsLookup[id]) {\n        delete selectionLookup[id];\n        hasChanged = true;\n      }\n    });\n\n    if (hasChanged) {\n      apiRef.current.setSelectionModel(Object.values(selectionLookup));\n    }\n  }, [apiRef, props.keepNonExistentRowsSelected]);\n  const handleSingleRowSelection = React.useCallback((id, event) => {\n    const hasCtrlKey = event.metaKey || event.ctrlKey; // multiple selection is only allowed if:\n    // - it is a checkboxSelection\n    // - it is a keyboard selection\n    // - Ctrl is pressed\n\n    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);\n    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;\n    const isSelected = apiRef.current.isRowSelected(id);\n\n    if (resetSelection) {\n      apiRef.current.selectRow(id, !isMultipleSelectionDisabled ? !isSelected : true, true);\n    } else {\n      apiRef.current.selectRow(id, !isSelected, false);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);\n  const handleCellClick = React.useCallback((params, event) => {\n    if (disableSelectionOnClick) {\n      return;\n    }\n\n    if (params.field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {\n      // click on checkbox should not trigger row selection\n      return;\n    }\n\n    if (params.field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {\n      // click to open the detail panel should not select the row\n      return;\n    }\n\n    if (params.field) {\n      const column = apiRef.current.getColumn(params.field);\n\n      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {\n        return;\n      }\n    }\n\n    if (params.rowNode.isPinned) {\n      return;\n    }\n\n    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      handleSingleRowSelection(params.id, event);\n    }\n  }, [disableSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandMouseRowRangeSelection, handleSingleRowSelection]);\n  const preventSelectionOnShift = React.useCallback((params, event) => {\n    if (canHaveMultipleSelection && event.shiftKey) {\n      var _window$getSelection;\n\n      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();\n    }\n  }, [canHaveMultipleSelection]);\n  const handleRowSelectionCheckboxChange = React.useCallback((params, event) => {\n    if (event.nativeEvent.shiftKey) {\n      expandMouseRowRangeSelection(params.id);\n    } else {\n      apiRef.current.selectRow(params.id, params.value);\n    }\n  }, [apiRef, expandMouseRowRangeSelection]);\n  const handleHeaderSelectionCheckboxChange = React.useCallback(params => {\n    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;\n    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridVisibleSortedRowIdsSelector(apiRef);\n    apiRef.current.selectRows(rowsToBeSelected, params.value);\n  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);\n  const handleCellKeyDown = React.useCallback((params, event) => {\n    // Get the most recent cell mode because it may have been changed by another listener\n    if (apiRef.current.getCellMode(params.id, params.field) === GridCellModes.Edit) {\n      return;\n    } // Ignore portal\n    // Do not apply shortcuts if the focus is not on the cell root component\n\n\n    if (!event.currentTarget.contains(event.target)) {\n      return;\n    }\n\n    if (isNavigationKey(event.key) && event.shiftKey) {\n      // The cell that has focus after the keyboard navigation\n      const focusCell = gridFocusCellSelector(apiRef);\n\n      if (focusCell && focusCell.id !== params.id) {\n        event.preventDefault();\n        const isNextRowSelected = apiRef.current.isRowSelected(focusCell.id);\n\n        if (!canHaveMultipleSelection) {\n          apiRef.current.selectRow(focusCell.id, !isNextRowSelected, true);\n          return;\n        }\n\n        const newRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(focusCell.id);\n        const previousRowIndex = apiRef.current.getRowIndexRelativeToVisibleRows(params.id);\n        let start;\n        let end;\n\n        if (newRowIndex > previousRowIndex) {\n          if (isNextRowSelected) {\n            // We are navigating to the bottom of the page and adding selected rows\n            start = previousRowIndex;\n            end = newRowIndex - 1;\n          } else {\n            // We are navigating to the bottom of the page and removing selected rows\n            start = previousRowIndex;\n            end = newRowIndex;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isNextRowSelected) {\n            // We are navigating to the top of the page and removing selected rows\n            start = newRowIndex + 1;\n            end = previousRowIndex;\n          } else {\n            // We are navigating to the top of the page and adding selected rows\n            start = newRowIndex;\n            end = previousRowIndex;\n          }\n        }\n\n        const rowsBetweenStartAndEnd = visibleRows.rows.slice(start, end + 1).map(row => row.id);\n        apiRef.current.selectRows(rowsBetweenStartAndEnd, !isNextRowSelected);\n        return;\n      }\n    }\n\n    if (event.key === ' ' && event.shiftKey) {\n      event.preventDefault();\n      handleSingleRowSelection(params.id, event);\n      return;\n    }\n\n    if (event.key.toLowerCase() === 'a' && (event.ctrlKey || event.metaKey)) {\n      event.preventDefault();\n      selectRows(apiRef.current.getAllRowIds(), true);\n    }\n  }, [apiRef, handleSingleRowSelection, selectRows, visibleRows.rows, canHaveMultipleSelection]);\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', removeOutdatedSelection);\n  useGridApiEventHandler(apiRef, 'cellClick', handleCellClick);\n  useGridApiEventHandler(apiRef, 'rowSelectionCheckboxChange', handleRowSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'headerSelectionCheckboxChange', handleHeaderSelectionCheckboxChange);\n  useGridApiEventHandler(apiRef, 'cellMouseDown', preventSelectionOnShift);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handleCellKeyDown);\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    if (propSelectionModel !== undefined) {\n      apiRef.current.setSelectionModel(propSelectionModel);\n    }\n  }, [apiRef, propSelectionModel]);\n  const isStateControlled = propSelectionModel != null;\n  React.useEffect(() => {\n    if (isStateControlled) {\n      return;\n    } // props.isRowSelectable changed\n\n\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n\n    if (isRowSelectable) {\n      const newSelection = currentSelection.filter(id => isRowSelectable(id));\n\n      if (newSelection.length < currentSelection.length) {\n        apiRef.current.setSelectionModel(newSelection);\n      }\n    }\n  }, [apiRef, isRowSelectable, isStateControlled]);\n  React.useEffect(() => {\n    const currentSelection = gridSelectionStateSelector(apiRef.current.state);\n\n    if (!canHaveMultipleSelection && currentSelection.length > 1) {\n      const {\n        rows: currentPageRows\n      } = getVisibleRows(apiRef, {\n        pagination,\n        paginationMode\n      });\n      const currentPageRowsLookup = currentPageRows.reduce((acc, {\n        id\n      }) => {\n        acc[id] = true;\n        return acc;\n      }, {});\n      const firstSelectableRow = currentSelection.find(id => {\n        let isSelectable = true;\n\n        if (isRowSelectable) {\n          isSelectable = isRowSelectable(id);\n        }\n\n        return isSelectable && currentPageRowsLookup[id]; // Check if the row is in the current page\n      });\n      apiRef.current.setSelectionModel(firstSelectableRow !== undefined ? [firstSelectableRow] : []);\n    }\n  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleSelection, isRowSelectable, pagination, paginationMode]);\n};"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,sBAAsB,QAAQ,oCAAoC;AAC3E,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,aAAa,QAAQ,2BAA2B;AACzD,SAASC,sBAAsB,QAAQ,0BAA0B;AACjE,SAASC,0BAA0B,EAAEC,wBAAwB,EAAEC,yBAAyB,QAAQ,yBAAyB;AACzH,SAASC,4CAA4C,QAAQ,eAAe;AAC5E,SAASC,qBAAqB,QAAQ,iCAAiC;AACvE,SAASC,+BAA+B,QAAQ,8BAA8B;AAC9E,SAASC,+BAA+B,EAAEC,wBAAwB,QAAQ,iBAAiB;AAC3F,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAASC,eAAe,EAAEC,eAAe,QAAQ,8BAA8B;AAC/E,SAASC,cAAc,EAAEC,kBAAkB,QAAQ,gCAAgC;AACnF,SAASC,8BAA8B,QAAQ,+CAA+C;AAE9F,MAAMC,0BAA0B,GAAG,CAACC,kBAAkB,EAAEC,kBAAkB,KAAK;EAC7E,IAAID,kBAAkB,IAAI,IAAI,EAAE;IAC9B,OAAOA,kBAAkB;EAC3B;EAEA,IAAIE,KAAK,CAACC,OAAO,CAACH,kBAAkB,CAAC,EAAE;IACrC,OAAOA,kBAAkB;EAC3B;EAEA,IAAIC,kBAAkB,IAAIA,kBAAkB,CAAC,CAAC,CAAC,KAAKD,kBAAkB,EAAE;IACtE,OAAOC,kBAAkB;EAC3B;EAEA,OAAO,CAACD,kBAAkB,CAAC;AAC7B,CAAC;AAED,OAAO,MAAMI,yBAAyB,GAAG,CAACC,KAAK,EAAEC,KAAK,KAAK;EACzD,IAAIC,qBAAqB;EAEzB,OAAO5B,QAAQ,CAAC,CAAC,CAAC,EAAE0B,KAAK,EAAE;IACzBG,SAAS,EAAE,CAACD,qBAAqB,GAAGR,0BAA0B,CAACO,KAAK,CAACG,cAAc,CAAC,KAAK,IAAI,GAAGF,qBAAqB,GAAG;EAC1H,CAAC,CAAC;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMG,gBAAgB,GAAG,CAACC,MAAM,EAAEL,KAAK,KAAK;EACjD,MAAMM,MAAM,GAAG7B,aAAa,CAAC4B,MAAM,EAAE,kBAAkB,CAAC;EACxD,MAAME,kBAAkB,GAAGjC,KAAK,CAACkC,OAAO,CAAC,MAAM;IAC7C,OAAOf,0BAA0B,CAACO,KAAK,CAACG,cAAc,EAAExB,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC,CAAC;EAC3G,CAAC,EAAE,CAACM,MAAM,EAAEL,KAAK,CAACG,cAAc,CAAC,CAAC;EAClC,MAAMO,cAAc,GAAGpC,KAAK,CAACqC,MAAM,CAAC,IAAI,CAAC;EACzCN,MAAM,CAACI,OAAO,CAACG,6BAA6B,CAAC;IAC3CC,OAAO,EAAE,WAAW;IACpBC,SAAS,EAAEP,kBAAkB;IAC7BQ,YAAY,EAAEf,KAAK,CAACgB,sBAAsB;IAC1CC,aAAa,EAAEtC,0BAA0B;IACzCuC,WAAW,EAAE;EACf,CAAC,CAAC;EACF,MAAM;IACJC,iBAAiB;IACjBC,wBAAwB;IACxBC,uBAAuB;IACvBC,UAAU;IACVC,cAAc;IACdC,eAAe,EAAEC;EACnB,CAAC,GAAGzB,KAAK;EACT,MAAM0B,wBAAwB,GAAG,CAACN,wBAAwB,IAAID,iBAAiB;EAC/E,MAAMQ,WAAW,GAAGpC,kBAAkB,CAACc,MAAM,EAAEL,KAAK,CAAC;EACrD,MAAM4B,4BAA4B,GAAGtD,KAAK,CAACuD,WAAW,CAACC,EAAE,IAAI;IAC3D,IAAIC,qBAAqB;IAEzB,IAAIC,KAAK,GAAGF,EAAE;IACd,MAAMG,OAAO,GAAG,CAACF,qBAAqB,GAAGrB,cAAc,CAACD,OAAO,KAAK,IAAI,GAAGsB,qBAAqB,GAAGD,EAAE;IACrG,MAAMI,UAAU,GAAG7B,MAAM,CAACI,OAAO,CAAC0B,aAAa,CAACL,EAAE,CAAC;IAEnD,IAAII,UAAU,EAAE;MACd,MAAME,aAAa,GAAGpD,+BAA+B,CAACqB,MAAM,CAAC;MAC7D,MAAMgC,UAAU,GAAGD,aAAa,CAACE,SAAS,CAACC,KAAK,IAAIA,KAAK,KAAKN,OAAO,CAAC;MACtE,MAAMO,QAAQ,GAAGJ,aAAa,CAACE,SAAS,CAACC,KAAK,IAAIA,KAAK,KAAKP,KAAK,CAAC;MAElE,IAAIK,UAAU,KAAKG,QAAQ,EAAE;QAC3B;MACF;MAEA,IAAIH,UAAU,GAAGG,QAAQ,EAAE;QACzBR,KAAK,GAAGI,aAAa,CAACI,QAAQ,GAAG,CAAC,CAAC;MACrC,CAAC,MAAM;QACLR,KAAK,GAAGI,aAAa,CAACI,QAAQ,GAAG,CAAC,CAAC;MACrC;IACF;IAEA9B,cAAc,CAACD,OAAO,GAAGqB,EAAE;IAC3BzB,MAAM,CAACI,OAAO,CAACgC,cAAc,CAAC;MAC5BR,OAAO;MACPD;IACF,CAAC,EAAE,CAACE,UAAU,CAAC;EACjB,CAAC,EAAE,CAAC7B,MAAM,CAAC,CAAC;EACZ;AACF;AACA;;EAEE,MAAMqC,iBAAiB,GAAGpE,KAAK,CAACuD,WAAW,CAACc,KAAK,IAAI;IACnD,MAAMC,YAAY,GAAGjE,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC;IAErE,IAAI6C,YAAY,KAAKD,KAAK,EAAE;MAC1BrC,MAAM,CAACuC,KAAK,CAAE,yBAAwB,CAAC;MACvCxC,MAAM,CAACI,OAAO,CAACqC,QAAQ,CAAC/C,KAAK,IAAI1B,QAAQ,CAAC,CAAC,CAAC,EAAE0B,KAAK,EAAE;QACnDG,SAAS,EAAEyC;MACb,CAAC,CAAC,CAAC;MACHtC,MAAM,CAACI,OAAO,CAACsC,WAAW,EAAE;IAC9B;EACF,CAAC,EAAE,CAAC1C,MAAM,EAAEC,MAAM,CAAC,CAAC;EACpB,MAAM6B,aAAa,GAAG7D,KAAK,CAACuD,WAAW,CAACC,EAAE,IAAInD,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC,CAACiD,QAAQ,CAAClB,EAAE,CAAC,EAAE,CAACzB,MAAM,CAAC,CAAC;EACtH,MAAMmB,eAAe,GAAGlD,KAAK,CAACuD,WAAW,CAACC,EAAE,IAAI;IAC9C,IAAIL,mBAAmB,IAAI,CAACA,mBAAmB,CAACpB,MAAM,CAACI,OAAO,CAACwC,YAAY,CAACnB,EAAE,CAAC,CAAC,EAAE;MAChF,OAAO,KAAK;IACd;IAEA,MAAMoB,OAAO,GAAG7C,MAAM,CAACI,OAAO,CAAC0C,UAAU,CAACrB,EAAE,CAAC;IAE7C,IAAI,CAACoB,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACE,QAAQ,MAAM,QAAQ,IAAIF,OAAO,IAAI,IAAI,IAAIA,OAAO,CAACG,QAAQ,EAAE;MACrG,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb,CAAC,EAAE,CAAChD,MAAM,EAAEoB,mBAAmB,CAAC,CAAC;EACjC,MAAM6B,eAAe,GAAGhF,KAAK,CAACuD,WAAW,CAAC,MAAMjD,wBAAwB,CAACyB,MAAM,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EAC3F,MAAMkD,SAAS,GAAGjF,KAAK,CAACuD,WAAW,CAAC,UAACC,EAAE,EAAgD;IAAA,IAA9CI,UAAU,uEAAG,IAAI;IAAA,IAAEsB,cAAc,uEAAG,KAAK;IAChF,IAAI,CAACnD,MAAM,CAACI,OAAO,CAACe,eAAe,CAACM,EAAE,CAAC,EAAE;MACvC;IACF;IAEApB,cAAc,CAACD,OAAO,GAAGqB,EAAE;IAE3B,IAAI0B,cAAc,EAAE;MAClBlD,MAAM,CAACuC,KAAK,CAAE,6BAA4Bf,EAAG,EAAC,CAAC;MAC/CzB,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAACR,UAAU,GAAG,CAACJ,EAAE,CAAC,GAAG,EAAE,CAAC;IAC1D,CAAC,MAAM;MACLxB,MAAM,CAACuC,KAAK,CAAE,8BAA6Bf,EAAG,EAAC,CAAC;MAChD,MAAM5B,SAAS,GAAGvB,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC;MAClE,MAAM0D,YAAY,GAAGvD,SAAS,CAACwD,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAK7B,EAAE,CAAC;MAEtD,IAAII,UAAU,EAAE;QACduB,YAAY,CAACG,IAAI,CAAC9B,EAAE,CAAC;MACvB;MAEA,MAAM+B,gBAAgB,GAAGJ,YAAY,CAACK,MAAM,GAAG,CAAC,IAAIpC,wBAAwB;MAE5E,IAAImC,gBAAgB,EAAE;QACpBxD,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAACe,YAAY,CAAC;MAChD;IACF;EACF,CAAC,EAAE,CAACpD,MAAM,EAAEC,MAAM,EAAEoB,wBAAwB,CAAC,CAAC;EAC9C,MAAMqC,UAAU,GAAGzF,KAAK,CAACuD,WAAW,CAAC,UAACmC,GAAG,EAAgD;IAAA,IAA9C9B,UAAU,uEAAG,IAAI;IAAA,IAAEsB,cAAc,uEAAG,KAAK;IAClFlD,MAAM,CAACuC,KAAK,CAAE,oCAAmC,CAAC;IAClD,MAAMoB,aAAa,GAAGD,GAAG,CAACN,MAAM,CAAC5B,EAAE,IAAIzB,MAAM,CAACI,OAAO,CAACe,eAAe,CAACM,EAAE,CAAC,CAAC;IAC1E,IAAI2B,YAAY;IAEhB,IAAID,cAAc,EAAE;MAClBC,YAAY,GAAGvB,UAAU,GAAG+B,aAAa,GAAG,EAAE;IAChD,CAAC,MAAM;MACL;MACA,MAAMC,eAAe,GAAG7F,QAAQ,CAAC,CAAC,CAAC,EAAEQ,yBAAyB,CAACwB,MAAM,CAAC,CAAC;MAEvE4D,aAAa,CAACE,OAAO,CAACrC,EAAE,IAAI;QAC1B,IAAII,UAAU,EAAE;UACdgC,eAAe,CAACpC,EAAE,CAAC,GAAGA,EAAE;QAC1B,CAAC,MAAM;UACL,OAAOoC,eAAe,CAACpC,EAAE,CAAC;QAC5B;MACF,CAAC,CAAC;MACF2B,YAAY,GAAGW,MAAM,CAACC,MAAM,CAACH,eAAe,CAAC;IAC/C;IAEA,MAAML,gBAAgB,GAAGJ,YAAY,CAACK,MAAM,GAAG,CAAC,IAAIpC,wBAAwB;IAE5E,IAAImC,gBAAgB,EAAE;MACpBxD,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAACe,YAAY,CAAC;IAChD;EACF,CAAC,EAAE,CAACpD,MAAM,EAAEC,MAAM,EAAEoB,wBAAwB,CAAC,CAAC;EAC9C,MAAMe,cAAc,GAAGnE,KAAK,CAACuD,WAAW,CAAC,gBAGA;IAAA,IAHC;MACxCI,OAAO;MACPD;IACF,CAAC;IAAA,IAAEE,UAAU,uEAAG,IAAI;IAAA,IAAEsB,cAAc;IAClC,IAAI,CAACnD,MAAM,CAACI,OAAO,CAAC6D,MAAM,CAACrC,OAAO,CAAC,IAAI,CAAC5B,MAAM,CAACI,OAAO,CAAC6D,MAAM,CAACtC,KAAK,CAAC,EAAE;MACpE;IACF;IAEA1B,MAAM,CAACuC,KAAK,CAAE,gCAA+BZ,OAAQ,WAAUD,KAAM,EAAC,CAAC,CAAC,CAAC;;IAEzE,MAAMuC,cAAc,GAAGvF,+BAA+B,CAACqB,MAAM,CAAC;IAC9D,MAAMgC,UAAU,GAAGkC,cAAc,CAACC,OAAO,CAACvC,OAAO,CAAC;IAClD,MAAMO,QAAQ,GAAG+B,cAAc,CAACC,OAAO,CAACxC,KAAK,CAAC;IAC9C,MAAM,CAACyC,KAAK,EAAEC,GAAG,CAAC,GAAGrC,UAAU,GAAGG,QAAQ,GAAG,CAACA,QAAQ,EAAEH,UAAU,CAAC,GAAG,CAACA,UAAU,EAAEG,QAAQ,CAAC;IAC5F,MAAMmC,sBAAsB,GAAGJ,cAAc,CAACK,KAAK,CAACH,KAAK,EAAEC,GAAG,GAAG,CAAC,CAAC;IACnErE,MAAM,CAACI,OAAO,CAACsD,UAAU,CAACY,sBAAsB,EAAEzC,UAAU,EAAEsB,cAAc,CAAC;EAC/E,CAAC,EAAE,CAACnD,MAAM,EAAEC,MAAM,CAAC,CAAC;EACpB,MAAMuE,YAAY,GAAG;IACnBtB,SAAS;IACTQ,UAAU;IACVtB,cAAc;IACdC,iBAAiB;IACjBY,eAAe;IACfnB,aAAa;IACbX;EACF,CAAC;EACDhD,gBAAgB,CAAC6B,MAAM,EAAEwE,YAAY,EAAE,kBAAkB,CAAC;EAC1D;AACF;AACA;;EAEE,MAAMC,uBAAuB,GAAGxG,KAAK,CAACuD,WAAW,CAAC,MAAM;IACtD,IAAI7B,KAAK,CAAC+E,2BAA2B,EAAE;MACrC;IACF;IAEA,MAAMC,gBAAgB,GAAGrG,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC;IACzE,MAAMkF,UAAU,GAAGvG,sBAAsB,CAAC2B,MAAM,CAAC,CAAC,CAAC;;IAEnD,MAAM6D,eAAe,GAAG7F,QAAQ,CAAC,CAAC,CAAC,EAAEQ,yBAAyB,CAACwB,MAAM,CAAC,CAAC;IAEvE,IAAI6E,UAAU,GAAG,KAAK;IACtBF,gBAAgB,CAACb,OAAO,CAACrC,EAAE,IAAI;MAC7B,IAAI,CAACmD,UAAU,CAACnD,EAAE,CAAC,EAAE;QACnB,OAAOoC,eAAe,CAACpC,EAAE,CAAC;QAC1BoD,UAAU,GAAG,IAAI;MACnB;IACF,CAAC,CAAC;IAEF,IAAIA,UAAU,EAAE;MACd7E,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAAC0B,MAAM,CAACC,MAAM,CAACH,eAAe,CAAC,CAAC;IAClE;EACF,CAAC,EAAE,CAAC7D,MAAM,EAAEL,KAAK,CAAC+E,2BAA2B,CAAC,CAAC;EAC/C,MAAMI,wBAAwB,GAAG7G,KAAK,CAACuD,WAAW,CAAC,CAACC,EAAE,EAAEsD,KAAK,KAAK;IAChE,MAAMC,UAAU,GAAGD,KAAK,CAACE,OAAO,IAAIF,KAAK,CAACG,OAAO,CAAC,CAAC;IACnD;IACA;IACA;;IAEA,MAAMC,2BAA2B,GAAG,CAACrE,iBAAiB,IAAI,CAACkE,UAAU,IAAI,CAACjG,eAAe,CAACgG,KAAK,CAAC;IAChG,MAAM5B,cAAc,GAAG,CAAC9B,wBAAwB,IAAI8D,2BAA2B;IAC/E,MAAMtD,UAAU,GAAG7B,MAAM,CAACI,OAAO,CAAC0B,aAAa,CAACL,EAAE,CAAC;IAEnD,IAAI0B,cAAc,EAAE;MAClBnD,MAAM,CAACI,OAAO,CAAC8C,SAAS,CAACzB,EAAE,EAAE,CAAC0D,2BAA2B,GAAG,CAACtD,UAAU,GAAG,IAAI,EAAE,IAAI,CAAC;IACvF,CAAC,MAAM;MACL7B,MAAM,CAACI,OAAO,CAAC8C,SAAS,CAACzB,EAAE,EAAE,CAACI,UAAU,EAAE,KAAK,CAAC;IAClD;EACF,CAAC,EAAE,CAAC7B,MAAM,EAAEqB,wBAAwB,EAAEP,iBAAiB,CAAC,CAAC;EACzD,MAAMsE,eAAe,GAAGnH,KAAK,CAACuD,WAAW,CAAC,CAAC6D,MAAM,EAAEN,KAAK,KAAK;IAC3D,IAAI/D,uBAAuB,EAAE;MAC3B;IACF;IAEA,IAAIqE,MAAM,CAACC,KAAK,KAAK1G,+BAA+B,CAAC0G,KAAK,EAAE;MAC1D;MACA;IACF;IAEA,IAAID,MAAM,CAACC,KAAK,KAAKnG,8BAA8B,EAAE;MACnD;MACA;IACF;IAEA,IAAIkG,MAAM,CAACC,KAAK,EAAE;MAChB,MAAMC,MAAM,GAAGvF,MAAM,CAACI,OAAO,CAACoF,SAAS,CAACH,MAAM,CAACC,KAAK,CAAC;MAErD,IAAIC,MAAM,CAACE,IAAI,KAAK5G,wBAAwB,EAAE;QAC5C;MACF;IACF;IAEA,IAAIwG,MAAM,CAACxC,OAAO,CAACG,QAAQ,EAAE;MAC3B;IACF;IAEA,IAAI+B,KAAK,CAACW,QAAQ,KAAKrE,wBAAwB,IAAIP,iBAAiB,CAAC,EAAE;MACrES,4BAA4B,CAAC8D,MAAM,CAAC5D,EAAE,CAAC;IACzC,CAAC,MAAM;MACLqD,wBAAwB,CAACO,MAAM,CAAC5D,EAAE,EAAEsD,KAAK,CAAC;IAC5C;EACF,CAAC,EAAE,CAAC/D,uBAAuB,EAAEK,wBAAwB,EAAEP,iBAAiB,EAAEd,MAAM,EAAEuB,4BAA4B,EAAEuD,wBAAwB,CAAC,CAAC;EAC1I,MAAMa,uBAAuB,GAAG1H,KAAK,CAACuD,WAAW,CAAC,CAAC6D,MAAM,EAAEN,KAAK,KAAK;IACnE,IAAI1D,wBAAwB,IAAI0D,KAAK,CAACW,QAAQ,EAAE;MAC9C,IAAIE,oBAAoB;MAExB,CAACA,oBAAoB,GAAGC,MAAM,CAACC,YAAY,EAAE,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGF,oBAAoB,CAACG,eAAe,EAAE;IAC1G;EACF,CAAC,EAAE,CAAC1E,wBAAwB,CAAC,CAAC;EAC9B,MAAM2E,gCAAgC,GAAG/H,KAAK,CAACuD,WAAW,CAAC,CAAC6D,MAAM,EAAEN,KAAK,KAAK;IAC5E,IAAIA,KAAK,CAACkB,WAAW,CAACP,QAAQ,EAAE;MAC9BnE,4BAA4B,CAAC8D,MAAM,CAAC5D,EAAE,CAAC;IACzC,CAAC,MAAM;MACLzB,MAAM,CAACI,OAAO,CAAC8C,SAAS,CAACmC,MAAM,CAAC5D,EAAE,EAAE4D,MAAM,CAACa,KAAK,CAAC;IACnD;EACF,CAAC,EAAE,CAAClG,MAAM,EAAEuB,4BAA4B,CAAC,CAAC;EAC1C,MAAM4E,mCAAmC,GAAGlI,KAAK,CAACuD,WAAW,CAAC6D,MAAM,IAAI;IACtE,MAAMe,iCAAiC,GAAGzG,KAAK,CAAC0G,4BAA4B,IAAI1G,KAAK,CAACsB,UAAU;IAChG,MAAMqF,gBAAgB,GAAGF,iCAAiC,GAAG3H,4CAA4C,CAACuB,MAAM,CAAC,GAAGrB,+BAA+B,CAACqB,MAAM,CAAC;IAC3JA,MAAM,CAACI,OAAO,CAACsD,UAAU,CAAC4C,gBAAgB,EAAEjB,MAAM,CAACa,KAAK,CAAC;EAC3D,CAAC,EAAE,CAAClG,MAAM,EAAEL,KAAK,CAAC0G,4BAA4B,EAAE1G,KAAK,CAACsB,UAAU,CAAC,CAAC;EAClE,MAAMsF,iBAAiB,GAAGtI,KAAK,CAACuD,WAAW,CAAC,CAAC6D,MAAM,EAAEN,KAAK,KAAK;IAC7D;IACA,IAAI/E,MAAM,CAACI,OAAO,CAACoG,WAAW,CAACnB,MAAM,CAAC5D,EAAE,EAAE4D,MAAM,CAACC,KAAK,CAAC,KAAKxG,aAAa,CAAC2H,IAAI,EAAE;MAC9E;IACF,CAAC,CAAC;IACF;;IAGA,IAAI,CAAC1B,KAAK,CAAC2B,aAAa,CAACC,QAAQ,CAAC5B,KAAK,CAAC6B,MAAM,CAAC,EAAE;MAC/C;IACF;IAEA,IAAI5H,eAAe,CAAC+F,KAAK,CAAC8B,GAAG,CAAC,IAAI9B,KAAK,CAACW,QAAQ,EAAE;MAChD;MACA,MAAMoB,SAAS,GAAGpI,qBAAqB,CAACsB,MAAM,CAAC;MAE/C,IAAI8G,SAAS,IAAIA,SAAS,CAACrF,EAAE,KAAK4D,MAAM,CAAC5D,EAAE,EAAE;QAC3CsD,KAAK,CAACgC,cAAc,EAAE;QACtB,MAAMC,iBAAiB,GAAGhH,MAAM,CAACI,OAAO,CAAC0B,aAAa,CAACgF,SAAS,CAACrF,EAAE,CAAC;QAEpE,IAAI,CAACJ,wBAAwB,EAAE;UAC7BrB,MAAM,CAACI,OAAO,CAAC8C,SAAS,CAAC4D,SAAS,CAACrF,EAAE,EAAE,CAACuF,iBAAiB,EAAE,IAAI,CAAC;UAChE;QACF;QAEA,MAAMC,WAAW,GAAGjH,MAAM,CAACI,OAAO,CAAC8G,gCAAgC,CAACJ,SAAS,CAACrF,EAAE,CAAC;QACjF,MAAM0F,gBAAgB,GAAGnH,MAAM,CAACI,OAAO,CAAC8G,gCAAgC,CAAC7B,MAAM,CAAC5D,EAAE,CAAC;QACnF,IAAI2C,KAAK;QACT,IAAIC,GAAG;QAEP,IAAI4C,WAAW,GAAGE,gBAAgB,EAAE;UAClC,IAAIH,iBAAiB,EAAE;YACrB;YACA5C,KAAK,GAAG+C,gBAAgB;YACxB9C,GAAG,GAAG4C,WAAW,GAAG,CAAC;UACvB,CAAC,MAAM;YACL;YACA7C,KAAK,GAAG+C,gBAAgB;YACxB9C,GAAG,GAAG4C,WAAW;UACnB;QACF,CAAC,MAAM;UACL;UACA,IAAID,iBAAiB,EAAE;YACrB;YACA5C,KAAK,GAAG6C,WAAW,GAAG,CAAC;YACvB5C,GAAG,GAAG8C,gBAAgB;UACxB,CAAC,MAAM;YACL;YACA/C,KAAK,GAAG6C,WAAW;YACnB5C,GAAG,GAAG8C,gBAAgB;UACxB;QACF;QAEA,MAAM7C,sBAAsB,GAAGhD,WAAW,CAAC8F,IAAI,CAAC7C,KAAK,CAACH,KAAK,EAAEC,GAAG,GAAG,CAAC,CAAC,CAACgD,GAAG,CAACC,GAAG,IAAIA,GAAG,CAAC7F,EAAE,CAAC;QACxFzB,MAAM,CAACI,OAAO,CAACsD,UAAU,CAACY,sBAAsB,EAAE,CAAC0C,iBAAiB,CAAC;QACrE;MACF;IACF;IAEA,IAAIjC,KAAK,CAAC8B,GAAG,KAAK,GAAG,IAAI9B,KAAK,CAACW,QAAQ,EAAE;MACvCX,KAAK,CAACgC,cAAc,EAAE;MACtBjC,wBAAwB,CAACO,MAAM,CAAC5D,EAAE,EAAEsD,KAAK,CAAC;MAC1C;IACF;IAEA,IAAIA,KAAK,CAAC8B,GAAG,CAACU,WAAW,EAAE,KAAK,GAAG,KAAKxC,KAAK,CAACG,OAAO,IAAIH,KAAK,CAACE,OAAO,CAAC,EAAE;MACvEF,KAAK,CAACgC,cAAc,EAAE;MACtBrD,UAAU,CAAC1D,MAAM,CAACI,OAAO,CAACoH,YAAY,EAAE,EAAE,IAAI,CAAC;IACjD;EACF,CAAC,EAAE,CAACxH,MAAM,EAAE8E,wBAAwB,EAAEpB,UAAU,EAAEpC,WAAW,CAAC8F,IAAI,EAAE/F,wBAAwB,CAAC,CAAC;EAC9FnD,sBAAsB,CAAC8B,MAAM,EAAE,eAAe,EAAEyE,uBAAuB,CAAC;EACxEvG,sBAAsB,CAAC8B,MAAM,EAAE,WAAW,EAAEoF,eAAe,CAAC;EAC5DlH,sBAAsB,CAAC8B,MAAM,EAAE,4BAA4B,EAAEgG,gCAAgC,CAAC;EAC9F9H,sBAAsB,CAAC8B,MAAM,EAAE,+BAA+B,EAAEmG,mCAAmC,CAAC;EACpGjI,sBAAsB,CAAC8B,MAAM,EAAE,eAAe,EAAE2F,uBAAuB,CAAC;EACxEzH,sBAAsB,CAAC8B,MAAM,EAAE,aAAa,EAAEuG,iBAAiB,CAAC;EAChE;AACF;AACA;;EAEEtI,KAAK,CAACwJ,SAAS,CAAC,MAAM;IACpB,IAAIvH,kBAAkB,KAAKwH,SAAS,EAAE;MACpC1H,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAACnC,kBAAkB,CAAC;IACtD;EACF,CAAC,EAAE,CAACF,MAAM,EAAEE,kBAAkB,CAAC,CAAC;EAChC,MAAMyH,iBAAiB,GAAGzH,kBAAkB,IAAI,IAAI;EACpDjC,KAAK,CAACwJ,SAAS,CAAC,MAAM;IACpB,IAAIE,iBAAiB,EAAE;MACrB;IACF,CAAC,CAAC;;IAGF,MAAMhD,gBAAgB,GAAGrG,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC;IAEzE,IAAIyB,eAAe,EAAE;MACnB,MAAMiC,YAAY,GAAGuB,gBAAgB,CAACtB,MAAM,CAAC5B,EAAE,IAAIN,eAAe,CAACM,EAAE,CAAC,CAAC;MAEvE,IAAI2B,YAAY,CAACK,MAAM,GAAGkB,gBAAgB,CAAClB,MAAM,EAAE;QACjDzD,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAACe,YAAY,CAAC;MAChD;IACF;EACF,CAAC,EAAE,CAACpD,MAAM,EAAEmB,eAAe,EAAEwG,iBAAiB,CAAC,CAAC;EAChD1J,KAAK,CAACwJ,SAAS,CAAC,MAAM;IACpB,MAAM9C,gBAAgB,GAAGrG,0BAA0B,CAAC0B,MAAM,CAACI,OAAO,CAACV,KAAK,CAAC;IAEzE,IAAI,CAAC2B,wBAAwB,IAAIsD,gBAAgB,CAAClB,MAAM,GAAG,CAAC,EAAE;MAC5D,MAAM;QACJ2D,IAAI,EAAEQ;MACR,CAAC,GAAG3I,cAAc,CAACe,MAAM,EAAE;QACzBiB,UAAU;QACVC;MACF,CAAC,CAAC;MACF,MAAM2G,qBAAqB,GAAGD,eAAe,CAACE,MAAM,CAAC,CAACC,GAAG,YAEnD;QAAA,IAFqD;UACzDtG;QACF,CAAC;QACCsG,GAAG,CAACtG,EAAE,CAAC,GAAG,IAAI;QACd,OAAOsG,GAAG;MACZ,CAAC,EAAE,CAAC,CAAC,CAAC;MACN,MAAMC,kBAAkB,GAAGrD,gBAAgB,CAACsD,IAAI,CAACxG,EAAE,IAAI;QACrD,IAAIyG,YAAY,GAAG,IAAI;QAEvB,IAAI/G,eAAe,EAAE;UACnB+G,YAAY,GAAG/G,eAAe,CAACM,EAAE,CAAC;QACpC;QAEA,OAAOyG,YAAY,IAAIL,qBAAqB,CAACpG,EAAE,CAAC,CAAC,CAAC;MACpD,CAAC,CAAC;;MACFzB,MAAM,CAACI,OAAO,CAACiC,iBAAiB,CAAC2F,kBAAkB,KAAKN,SAAS,GAAG,CAACM,kBAAkB,CAAC,GAAG,EAAE,CAAC;IAChG;EACF,CAAC,EAAE,CAAChI,MAAM,EAAEqB,wBAAwB,EAAEP,iBAAiB,EAAEC,wBAAwB,EAAEI,eAAe,EAAEF,UAAU,EAAEC,cAAc,CAAC,CAAC;AAClI,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}