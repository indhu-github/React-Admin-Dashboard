{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridDensityTypes } from '../../../models/gridDensity';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridDensitySelector } from './densitySelector';\nimport { isDeepEqual } from '../../../utils/utils';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector } from '../columns';\nimport { unwrapGroupingColumnModel } from '../columnGrouping/useGridColumnGrouping';\nexport const COMPACT_DENSITY_FACTOR = 0.7;\nexport const COMFORTABLE_DENSITY_FACTOR = 1.3; // TODO v6: revise keeping headerHeight and rowHeight in state\n\nconst getUpdatedDensityState = (newDensity, newHeaderHeight, newRowHeight, newMaxDepth) => {\n  switch (newDensity) {\n    case GridDensityTypes.Compact:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMPACT_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMPACT_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMPACT_DENSITY_FACTOR\n      };\n    case GridDensityTypes.Comfortable:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMFORTABLE_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMFORTABLE_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMFORTABLE_DENSITY_FACTOR\n      };\n    default:\n      return {\n        value: newDensity,\n        headerHeight: newHeaderHeight,\n        rowHeight: newRowHeight,\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: 1\n      };\n  }\n};\nexport const densityStateInitializer = (state, props) => {\n  // TODO: think about improving this initialization. Could it be done in the useColumn initializer?\n  // TODO: manage to remove ts-ignore\n  let maxDepth;\n  if (props.columnGroupingModel == null || Object.keys(props.columnGroupingModel).length === 0) {\n    maxDepth = 0;\n  } else {\n    const unwrappedGroupingColumnModel = unwrapGroupingColumnModel(props.columnGroupingModel);\n    const columnsState = state.columns;\n    const visibleColumns = columnsState.all.filter(field => columnsState.columnVisibilityModel[field] !== false);\n    if (visibleColumns.length === 0) {\n      maxDepth = 0;\n    } else {\n      maxDepth = Math.max(...visibleColumns.map(field => {\n        var _unwrappedGroupingCol, _unwrappedGroupingCol2;\n        return (_unwrappedGroupingCol = (_unwrappedGroupingCol2 = unwrappedGroupingColumnModel[field]) == null ? void 0 : _unwrappedGroupingCol2.length) != null ? _unwrappedGroupingCol : 0;\n      }));\n    }\n  }\n  return _extends({}, state, {\n    density: getUpdatedDensityState(props.density, props.headerHeight, props.rowHeight, maxDepth)\n  });\n};\nexport const useGridDensity = (apiRef, props) => {\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const maxDepth = visibleColumns.length > 0 ? Math.max(...visibleColumns.map(column => {\n    var _column$groupPath$len, _column$groupPath;\n    return (_column$groupPath$len = (_column$groupPath = column.groupPath) == null ? void 0 : _column$groupPath.length) != null ? _column$groupPath$len : 0;\n  })) : 0;\n  const logger = useGridLogger(apiRef, 'useDensity');\n  const setDensity = React.useCallback(function (newDensity) {\n    let newHeaderHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : props.headerHeight;\n    let newRowHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : props.rowHeight;\n    let newMaxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maxDepth;\n    logger.debug(`Set grid density to ${newDensity}`);\n    apiRef.current.setState(state => {\n      const currentDensityState = gridDensitySelector(state);\n      const newDensityState = getUpdatedDensityState(newDensity, newHeaderHeight, newRowHeight, newMaxDepth);\n      if (isDeepEqual(currentDensityState, newDensityState)) {\n        return state;\n      }\n      return _extends({}, state, {\n        density: newDensityState\n      });\n    });\n    apiRef.current.forceUpdate();\n  }, [logger, apiRef, props.headerHeight, props.rowHeight, maxDepth]);\n  React.useEffect(() => {\n    apiRef.current.setDensity(props.density, props.headerHeight, props.rowHeight, maxDepth);\n  }, [apiRef, props.density, props.rowHeight, props.headerHeight, maxDepth]);\n  const densityApi = {\n    setDensity\n  };\n  useGridApiMethod(apiRef, densityApi, 'GridDensityApi');\n};","map":{"version":3,"names":["_extends","React","GridDensityTypes","useGridLogger","useGridApiMethod","gridDensitySelector","isDeepEqual","useGridSelector","gridVisibleColumnDefinitionsSelector","unwrapGroupingColumnModel","COMPACT_DENSITY_FACTOR","COMFORTABLE_DENSITY_FACTOR","getUpdatedDensityState","newDensity","newHeaderHeight","newRowHeight","newMaxDepth","Compact","value","headerHeight","Math","floor","rowHeight","headerGroupingMaxDepth","factor","Comfortable","densityStateInitializer","state","props","maxDepth","columnGroupingModel","Object","keys","length","unwrappedGroupingColumnModel","columnsState","columns","visibleColumns","all","filter","field","columnVisibilityModel","max","map","_unwrappedGroupingCol","_unwrappedGroupingCol2","density","useGridDensity","apiRef","column","_column$groupPath$len","_column$groupPath","groupPath","logger","setDensity","useCallback","debug","current","setState","currentDensityState","newDensityState","forceUpdate","useEffect","densityApi"],"sources":["/Users/indhuyelineni/Desktop/Projects/React-Dashboard/node_modules/@mui/x-data-grid/hooks/features/density/useGridDensity.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridDensityTypes } from '../../../models/gridDensity';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridDensitySelector } from './densitySelector';\nimport { isDeepEqual } from '../../../utils/utils';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector } from '../columns';\nimport { unwrapGroupingColumnModel } from '../columnGrouping/useGridColumnGrouping';\nexport const COMPACT_DENSITY_FACTOR = 0.7;\nexport const COMFORTABLE_DENSITY_FACTOR = 1.3; // TODO v6: revise keeping headerHeight and rowHeight in state\n\nconst getUpdatedDensityState = (newDensity, newHeaderHeight, newRowHeight, newMaxDepth) => {\n  switch (newDensity) {\n    case GridDensityTypes.Compact:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMPACT_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMPACT_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMPACT_DENSITY_FACTOR\n      };\n\n    case GridDensityTypes.Comfortable:\n      return {\n        value: newDensity,\n        headerHeight: Math.floor(newHeaderHeight * COMFORTABLE_DENSITY_FACTOR),\n        rowHeight: Math.floor(newRowHeight * COMFORTABLE_DENSITY_FACTOR),\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: COMFORTABLE_DENSITY_FACTOR\n      };\n\n    default:\n      return {\n        value: newDensity,\n        headerHeight: newHeaderHeight,\n        rowHeight: newRowHeight,\n        headerGroupingMaxDepth: newMaxDepth,\n        factor: 1\n      };\n  }\n};\n\nexport const densityStateInitializer = (state, props) => {\n  // TODO: think about improving this initialization. Could it be done in the useColumn initializer?\n  // TODO: manage to remove ts-ignore\n  let maxDepth;\n\n  if (props.columnGroupingModel == null || Object.keys(props.columnGroupingModel).length === 0) {\n    maxDepth = 0;\n  } else {\n    const unwrappedGroupingColumnModel = unwrapGroupingColumnModel(props.columnGroupingModel);\n    const columnsState = state.columns;\n    const visibleColumns = columnsState.all.filter(field => columnsState.columnVisibilityModel[field] !== false);\n\n    if (visibleColumns.length === 0) {\n      maxDepth = 0;\n    } else {\n      maxDepth = Math.max(...visibleColumns.map(field => {\n        var _unwrappedGroupingCol, _unwrappedGroupingCol2;\n\n        return (_unwrappedGroupingCol = (_unwrappedGroupingCol2 = unwrappedGroupingColumnModel[field]) == null ? void 0 : _unwrappedGroupingCol2.length) != null ? _unwrappedGroupingCol : 0;\n      }));\n    }\n  }\n\n  return _extends({}, state, {\n    density: getUpdatedDensityState(props.density, props.headerHeight, props.rowHeight, maxDepth)\n  });\n};\nexport const useGridDensity = (apiRef, props) => {\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const maxDepth = visibleColumns.length > 0 ? Math.max(...visibleColumns.map(column => {\n    var _column$groupPath$len, _column$groupPath;\n\n    return (_column$groupPath$len = (_column$groupPath = column.groupPath) == null ? void 0 : _column$groupPath.length) != null ? _column$groupPath$len : 0;\n  })) : 0;\n  const logger = useGridLogger(apiRef, 'useDensity');\n  const setDensity = React.useCallback((newDensity, newHeaderHeight = props.headerHeight, newRowHeight = props.rowHeight, newMaxDepth = maxDepth) => {\n    logger.debug(`Set grid density to ${newDensity}`);\n    apiRef.current.setState(state => {\n      const currentDensityState = gridDensitySelector(state);\n      const newDensityState = getUpdatedDensityState(newDensity, newHeaderHeight, newRowHeight, newMaxDepth);\n\n      if (isDeepEqual(currentDensityState, newDensityState)) {\n        return state;\n      }\n\n      return _extends({}, state, {\n        density: newDensityState\n      });\n    });\n    apiRef.current.forceUpdate();\n  }, [logger, apiRef, props.headerHeight, props.rowHeight, maxDepth]);\n  React.useEffect(() => {\n    apiRef.current.setDensity(props.density, props.headerHeight, props.rowHeight, maxDepth);\n  }, [apiRef, props.density, props.rowHeight, props.headerHeight, maxDepth]);\n  const densityApi = {\n    setDensity\n  };\n  useGridApiMethod(apiRef, densityApi, 'GridDensityApi');\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}